import time



class BBCON_:

    def __init__(self, behaviors, sensobs, motobs, arbitrator):

        self.behaviors_all = behaviors
        self.behaviors_active = []
        self.sensobs = sensobs
        self.motobs = motobs
        self.arbitrator = arbitrator

    def add_behavior(self, behavior):
        self.behaviors_all.append(behavior)

    def add_sensob(self, sensob):
        self.sensobs.append(sensob)

    def activate_behavior(self, behavior):
        if behavior in self.behaviors_all:
            self.behaviors_active.append(behavior)

    def deactivate_behavior(self, behavior):
        if behavior in self.behaviors_active:
            self.behaviors_active.remove(behavior)

    def run_one_timestep(self):

        for sensob in self.sensobs:
            sensob.update()

        for behavior in self.behaviors_active:
            behavior.update()

        recommendation,halt = self.arbitrator.choose_action
        if halt:
            #Stopp roboten, end run
            return

        self.motobs.update(recommendation)

        time.sleep(0.5)

        for sensob in self.sensobs:
            sensob.reset()


class Sensob:
    def __init__(self, sensors):
        self.sensors = sensors
        self.value = None

    def update(self):
        return self.get_value()

    def get_value(self):
        return


class Ultra(Sensob):
    def __init__(self, sensors):
        super().__init__(sensors)

    def get_value(self):
        values = []
        for sensor in self.sensors:  # Update og append values
            sensor.update()
            values.append(sensor.getvalue)
        limit = 0.01  # placeholder verdi
        close = 0
        far = 0
        # Logikk for å sjekke om en av avstandene er mindre enn limit, -> Kollisjon inc.
        for value in values:
            if value < limit:
                current_sensor = self.sensors[values.index(value)]
                # Logikk for å bryte av, få motorer til å unngå kollisjon
            if value < close:
                closest = value
            if value > far:
                far = value
                # Bruk verdiene til å skape et overblikk av omgivelsene, gjelder bare ved flere
                #


class Cam(Sensob):
    def __init__(self, sensors):
        super().__init__(sensors)




class Motob:

    def __init__(self, motors):

        self.motors = motors
        self.value = None

    def update(self,recommendation):
        self.operationalize(recommendation)

    def operationalize(self,recommendation):
        #logikk for å velge riktig value-vektor
        value_new = None

        self.value = value_new
        self.motors.set_value(self.value)





class Behavior:

    def __init__(self,bbcon,sensobs):
        self.bbcon = bbcon
        self.sensobs = sensobs
        self.motor_recommendation = None
        self.acive_flag = False
        self.halt_request = False
        self.priority = None
        self.match_degree = None
        self.weight = self.priority * self.match_degree


    def consider_deactivation(self):

        return

    def consider_activation(self):

        return

    def sense_and_act(self):

        #Bruk sensobs til å lage motor_recommendation

        return

    def update(self):
        if self.acive_flag:
            self.consider_deactivation()
        else:
            self.consider_activation()
        sense = self.sense_and_act()
        self.motor_recommendation = sense[0]
        self.match_degree = sense[1]
        self.halt_request = sense[2]
        self.weight = self.match_degree * self.priority


class Arbitrator:
    def __init__(self, bbcon):
        self.bbcon = bbcon

    def choose_action(self):
        behavior_winner = None
        weight_winner = 0
        for behavior in self.bbcon.behaviors_active:
            if behavior.weight > weight_winner:
                behavior_winner = behavior
                weight_winner = behavior.weight
